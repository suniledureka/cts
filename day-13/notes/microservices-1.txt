ECommerce Application  -> Different Modules like 1. Products, 2. Users  3. Orders  4. Payments   5. Shipment	6. Admin

the entire thing is in one project - one code base

Orders Controller     Orders Model    Orders View
Products Controller   Products Model  Products View

A Single Server ===> Presentation Layer (UI)  ---- Business Logic Layer  ------ Data Access Layer === Cards , Loans, Accounts  -- Single Supporting DB

Monolithic Application - where all functionalities are put in one single code base. When we take this build of the code base, we get a .jar or .war or .ear file

Advantages: Pros
1. as all the functionalities are put in one code base, testing and debugging becomes easy
2. Simpler development and deployment for smaller teams and applications
2. this entire project is maintained by one team - easy to maintain
3. Fewer cross-cutting concerns - all the non-functional requirements like security, auditing, logging etc
4. Better performance due to no network latency - all the code is deployed inside a single server, if accounts business logic wants to communicate with cards or loans- it is just going to be a method call inside the same server - no network call 

Disadvantages
1. Difficult to adopt new technologies - whenever I want to enhance my web application with a new framework or with new programming  languages or new technology - either we have to update my entire codebase or I need to continue with the old technology. Accounts team may want to move to a new framework or the latest version of the framework - but there will be a push back coming from the Cards and Loans team member 

2. Limited Agility - very limited agility inside monolithic applications - it is going to work like - you decided to move to a new framework or technology or a new language today - you can't do that immediately in a week or a months time . It is going to take lot of time to upgrade your monolithic applications

3. Single code base and difficult to maintain over the time as your application is growing with new enhancements day-by-day

4. Application is not going to be a fault tolerance - which means you are going to be having frequent issues with the scalability , availability of your monolithic applications 

5.  Tiny update and feature development always need a full deployment - ex: cards

6. tight coupling of all the modules
say after 1 or 2 months after application is live in production, some new functionalities are coming from business as part of enhancements - mainly for orders related like discounts, special offers etc

code base contains - Orders + Products + Users

since all residing in one code base, though there is no changes to the other modules and because of one module code changes (here Orders) - we are building the entire code once, generated update jar or war file , take downtime of the complete application and deploy the new jar or war file to the server

In monolithic applications there is no chance that some functionalities are up and some are down. If server down means all functionalities are down

We have various forms of Monolithic with the names like - Single-Process Monolith, Modular Monolith, Distributed Monolith
 
To overcome the limitations of Monolithic application - SOA 

SOA Architecture ==
It is an architectural style that focuses on organizing s/w systems as a collection of loosely coupled, interoperable services. It provides a way to design and develop large scale applications by decomposing them into smaller, modular services that can be independently developed, deployed and managed

Server-1 ====> Presentation Layer (UI)   Middleware ===> Enterprise Service Bus   Server2 ===> Accounts Service, Cards Service, Loans Service ----- Single Supporting DB 

Pros
1. Reusability of Services
2. Better Maintainability
3. Higher reliability
4. Parallel Development	
-------> we have separated the entire logic to separate components - like all your accounts related logic is going to stay in A/C Service, similarly for Cards and Loans
Coming to the UI Code is going to separated to a separate code base and it is going to be deployed into a separate server as well

Cons:
1. Complex Management due to communication protocols like SOAP
2. High investment costs due to Vendor in Middleware - to setup ESB we need to invest a lot because these are not open source - commercial products - Oracle has got ESB product - Oracle Enterprise Service Bus is a component of Oracle SOA Suite

3. Extra Overload - between UI and backend services

Microservices
=============
Microservices services are independently releasable services that are modelled around a business domain. A service encapsulates functionality and makes it accessible to other services via networks - One microservice might represent Accounts, another Cards, and yet another loans, but together they might constitute an entire bank system

Pros:
1. Easy to develop
2. Increased Agility
3. Ability to scale horizontally
4. Parallel Development
5. Modelled around a Business Domain

Cons:
1. Complexity
2. Infrastructure Overload - many servers to monitor - each service in each server
3. Security Concerns


----- accounts microservice -----
POST   http://localhost:8080/api/create    
Request Boy
{
    "name": "Sunil Joseph",
    "email": "sunil@example.com",
    "mobileNumber": "9848586878",
}

Response - Sucess
{
    "statusCode": "201",
    "statusMsg": "Account created successfully"
}

Response - Failure

{
    "apiPath": "uri=/api/create",
    "errorCode": "BAD_REQUEST",
    "errorMessage": "Customer already registered with given mobileNumber 9848586878",
    "errorTime": "2025-07-15T10:10:18.7687218"
}



==== Fetch Account Details 
GET   http://localhost:8080/api/fetch?mobileNumber=9848586878

Response - Success
{
    "name": "Sunil Joseph",
    "email": "sunil@example.com",
    "mobileNumber": "9848586878",
    "accountDto": {
        "accountNumber": 1603344650,
        "accountType": "Savings Account",
        "branchAddress": "Gachibowli, Hyderabad, Telangana"
    }
}


Response - Failure
{
    "apiPath": "uri=/api/fetch",
    "errorCode": "NOT_FOUND",
    "errorMessage": "Customer not found with the given input data mobileNumber : '9848586879'",
    "errorTime": "2025-07-15T10:13:15.2370345"
}



=== Update Account Details
PUT  http://localhost:8080/api/update

{
    "name": "Sunil",
    "email": "sunil@cognizant.com",
    "mobileNumber": "9848586879",
    "accountDto": {
        "accountNumber": 1255679041,
        "accountType": "Current Account",
        "branchAddress": "Ameerpet, Hyderabad, Telangana"
    }
}


Response - OK
{
    "statusCode": "200",
    "statusMsg": "Request processed successfully"
}



Response Failure
{
    "statusCode": "417",
    "statusMsg": "Update operation failed. Please try again or contact Dev team"
}


=== Delete account
DELETE   http://localhost:8080/api/delete?mobileNumber=9848586878

Response - OK

{
    "statusCode": "200",
    "statusMsg": "Request processed successfully"
}

Response - Failed
{
    "apiPath": "uri=/api/delete",
    "errorCode": "NOT_FOUND",
    "errorMessage": "Customer not found with the given input data mobileNumber : '9848586878'",
    "errorTime": "2025-07-15T10:22:32.3871373"
}


==== CARDS MICROSERVICE =====
Create Card - POST   http://localhost:9000/api/create?mobileNumber=9848586879

fetch Card Details - GET  http://localhost:9000/api/fetch?mobileNumber=9848586879

{
    "mobileNumber": "9848586879",
    "cardNumber": "100804408165",
    "cardType": "Credit Card",
    "totalLimit": 193000,
    "amountUsed": 0,
    "availableAmount": 193000
}


Update Card Details - http://localhost:9000/api/update
{
    "mobileNumber": "9848586879",
    "cardNumber": "100804408165",
    "cardType": "Debit Card",
    "totalLimit": 100000,
    "amountUsed": 10000,
    "availableAmount": 90000
}

Delete Card  - http://localhost:9000/api/delete?mobileNumber=9848586879


==== LOANS MICROSERVICE =======



============ Auditing =============
--- BaseEntity.java -----------
createdAt, createdBy, updatedAt, updatedBy

package com.wipro.accounts.entity;

@MappedSuperclass 
@EntityListeners(AuditingEntityListener.class)
@Data
public class BaseEntity {
    @CreatedDate
    @Column(updatable = false)
    private LocalDateTime createdAt;

    @CreatedBy
    @Column(updatable = false)
    private String createdBy;

    @LastModifiedDate
    @Column(insertable = false)
    private LocalDateTime updatedAt;

    @LastModifiedBy
    @Column(insertable = false)
    private String updatedBy;
}


----- Customer.java ------
customerId, name, email, mobileNumber

@Entity
@Getter
@Setter
@ToString
@AllArgsConstructor 
@NoArgsConstructor
public class Customer extends  BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name="customer_id")
    private Long customerId;

    private String name;

    private String email;

    @Column(name="mobile_number")
    private String mobileNumber;
}








